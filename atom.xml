<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[SuperBaboon's Blog]]></title>
  <link href="http://superbaboon.github.io/atom.xml" rel="self"/>
  <link href="http://superbaboon.github.io/"/>
  <updated>2014-03-27T16:58:31+08:00</updated>
  <id>http://superbaboon.github.io/</id>
  <author>
    <name><![CDATA[SuperBaboon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Logger源码学习--FileAppender]]></title>
    <link href="http://superbaboon.github.io/blog/2014/03/27/log4j-source-file-appender/"/>
    <updated>2014-03-27T16:51:26+08:00</updated>
    <id>http://superbaboon.github.io/blog/2014/03/27/log4j-source-file-appender</id>
    <content type="html"><![CDATA[<!--more-->


<p>疑惑：</p>

<ul>
<li>在多线程环境下，Log4j如何保证写文件的线程安全？</li>
</ul>


<p>二话不说，先上UML图，了解一下FileAppender的继承体系</p>

<p><img src="http://superbaboon.github.io/images/log4j_file-appender-uml.jpg" alt="FileAppender" /></p>

<h3>AppenderSkeleton（Abstract）</h3>

<p>该类主要提供了Appender的一些常用功能，主要是下面两个功能：</p>

<ul>
<li>Filter的增加和删除</li>
<li>给出了Appender接口中doAppender方法的执行骨架</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'>* This method performs threshold checks and invokes filters before
</span><span class='line'>* delegating actual logging to the subclasses specific {@link
</span><span class='line'>* AppenderSkeleton#append} method.
</span><span class='line'>* */
</span><span class='line'>public synchronized void doAppend(LoggingEvent event) {
</span><span class='line'>  if(closed) {
</span><span class='line'>    LogLog.error("Attempted to append to closed appender named ["+name+"].");
</span><span class='line'>    return;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  if(!isAsSevereAsThreshold(event.getLevel())) {
</span><span class='line'>    return;
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  Filter f = this.headFilter;
</span><span class='line'>
</span><span class='line'>  FILTER_LOOP:
</span><span class='line'>  while(f != null) {
</span><span class='line'>    switch(f.decide(event)) {
</span><span class='line'>    case Filter.DENY: return;
</span><span class='line'>    case Filter.ACCEPT: break FILTER_LOOP;
</span><span class='line'>    case Filter.NEUTRAL: f = f.next;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  this.append(event);    
</span><span class='line'>}
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p>注意：这里方法加入了<strong>synchronized</strong>关键字，表示doAppender是有线程同步的，这里可以看出这个是有一些问题的，带着这个问题，google搜索了一下<a href="http://mail-archives.apache.org/mod_mbox/logging-log4j-user/201003.mbox/%3C3101636D-567C-45A1-BEAA-8DC0ECD32960@apache.org%3E">why AppenderSkeleton.doAppend is synchronized</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>log4j 1.2 was designed a long time ago and relies on that big lock to provide thread safety.
</span><span class='line'> Other classes in log4j (layouts, appenders and the like) were designed assuming that they
</span><span class='line'>would be externally synchronized by that lock and likely not safe if that lock is bypassed.
</span><span class='line'>
</span><span class='line'>You could either implement the Appender interface or extend AppenderSkeleton but override
</span><span class='line'>doAppend (copying and pasting the implementation but without the synchronized modifier, but
</span><span class='line'>all appenders, layouts, etc used must be able to operate safely without that lock.
</span><span class='line'>
</span><span class='line'>Addressing this issue is one of the core design goals for log4j 2.0 (http://issues.apache.org/jira/browse/LOG4J2-3)</span></code></pre></td></tr></table></div></figure>


<p>流程如下</p>

<p><img src="http://superbaboon.github.io/images/AppenderSkeleton%E7%9A%84%E6%B5%81%E7%A8%8B%E5%A4%84%E7%90%86.jpg" alt="AppenderSkeleton的执行流程" /></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> Subclasses of &lt;code&gt;AppenderSkeleton&lt;/code&gt; should implement this
</span><span class='line'> method to perform actual logging. See also {@link #doAppend
</span><span class='line'> AppenderSkeleton.doAppend} method.
</span><span class='line'>
</span><span class='line'> @since 0.9.0
</span><span class='line'>*/
</span><span class='line'>protected abstract void append(LoggingEvent event);
</span></code></pre></td></tr></table></div></figure>


<p>append方法由具体的Appender实现去实现</p>

<h3>WriterAppender</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> This method is called by the {@link AppenderSkeleton#doAppend}
</span><span class='line'> method.
</span><span class='line'>
</span><span class='line'> &lt;p&gt;If the output stream exists and is writable then write a log
</span><span class='line'> statement to the output stream. Otherwise, write a single warning
</span><span class='line'> message to &lt;code&gt;System.err&lt;/code&gt;.
</span><span class='line'>
</span><span class='line'> &lt;p&gt;The format of the output will depend on this appender's
</span><span class='line'> layout.
</span><span class='line'>
</span><span class='line'>*/
</span><span class='line'>public void append(LoggingEvent event) {
</span><span class='line'>  if(!checkEntryConditions()) {
</span><span class='line'>    return;
</span><span class='line'>  }
</span><span class='line'>  subAppend(event);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>checkEntryConditions只是做一些常规的检验</p>

<p>subAppend(event)的源码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> Actual writing occurs here.
</span><span class='line'>
</span><span class='line'> &lt;p&gt;Most subclasses of &lt;code&gt;WriterAppender&lt;/code&gt; will need to
</span><span class='line'> override this method.
</span><span class='line'>
</span><span class='line'> @since 0.9.0 */
</span><span class='line'>protected void subAppend(LoggingEvent event) {
</span><span class='line'>    this.qw.write(this.layout.format(event));
</span><span class='line'>
</span><span class='line'>    if(layout.ignoresThrowable()) {
</span><span class='line'>      String[] s = event.getThrowableStrRep();
</span><span class='line'>      if (s != null) {
</span><span class='line'>  int len = s.length;
</span><span class='line'>  for(int i = 0; i &lt; len; i++) {
</span><span class='line'>    this.qw.write(s[i]);
</span><span class='line'>    this.qw.write(Layout.LINE_SEP);
</span><span class='line'>  }
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if(this.immediateFlush) {
</span><span class='line'>      this.qw.flush();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看出主要的写操作是代理给qw变量去做的，该变量是QuietWriter类型的，让我们来看看QuietWriter是何方神圣</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'>   QuietWriter does not throw exceptions when things go
</span><span class='line'>   wrong. Instead, it delegates error handling to its {@link ErrorHandler}. 
</span><span class='line'>
</span><span class='line'>   @author Ceki G&uuml;lc&uuml;
</span><span class='line'>
</span><span class='line'>   @since 0.7.3
</span><span class='line'>*/
</span><span class='line'>public class QuietWriter extends FilterWriter {
</span><span class='line'>
</span><span class='line'>  protected ErrorHandler errorHandler;
</span><span class='line'>
</span><span class='line'>  public
</span><span class='line'>  QuietWriter(Writer writer, ErrorHandler errorHandler) {
</span><span class='line'>    super(writer);
</span><span class='line'>    setErrorHandler(errorHandler);
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  public
</span><span class='line'>  void write(String string) {
</span><span class='line'>    try {
</span><span class='line'>      out.write(string);
</span><span class='line'>    } catch(IOException e) {
</span><span class='line'>      errorHandler.error("Failed to write ["+string+"].", e, 
</span><span class='line'>           ErrorCode.WRITE_FAILURE);
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  public
</span><span class='line'>  void flush() {
</span><span class='line'>    try {
</span><span class='line'>      out.flush();
</span><span class='line'>    } catch(IOException e) {
</span><span class='line'>      errorHandler.error("Failed to flush writer,", e, 
</span><span class='line'>           ErrorCode.FLUSH_FAILURE);
</span><span class='line'>    } 
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>  public
</span><span class='line'>  void setErrorHandler(ErrorHandler eh) {
</span><span class='line'>    if(eh == null) {
</span><span class='line'>      // This is a programming error on the part of the enclosing appender.
</span><span class='line'>      throw new IllegalArgumentException("Attempted to set null ErrorHandler.");
</span><span class='line'>    } else { 
</span><span class='line'>      this.errorHandler = eh;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>原来只是继承对FilterWriter的write方法做了容错处理</p>

<p>深入看了一下Writer的源码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * Writes a portion of a string.
</span><span class='line'> *
</span><span class='line'> * @param  str
</span><span class='line'> *         A String
</span><span class='line'> *
</span><span class='line'> * @param  off
</span><span class='line'> *         Offset from which to start writing characters
</span><span class='line'> *
</span><span class='line'> * @param  len
</span><span class='line'> *         Number of characters to write
</span><span class='line'> *
</span><span class='line'> * @throws  IndexOutOfBoundsException
</span><span class='line'> *          If &lt;tt&gt;off&lt;/tt&gt; is negative, or &lt;tt&gt;len&lt;/tt&gt; is negative,
</span><span class='line'> *          or &lt;tt&gt;off+len&lt;/tt&gt; is negative or greater than the length
</span><span class='line'> *          of the given string
</span><span class='line'> *
</span><span class='line'> * @throws  IOException
</span><span class='line'> *          If an I/O error occurs
</span><span class='line'> */
</span><span class='line'>public void write(String str, int off, int len) throws IOException {
</span><span class='line'>  synchronized (lock) {
</span><span class='line'>      char cbuf[];
</span><span class='line'>      if (len &lt;= writeBufferSize) {
</span><span class='line'>      if (writeBuffer == null) {
</span><span class='line'>          writeBuffer = new char[writeBufferSize];
</span><span class='line'>      }
</span><span class='line'>      cbuf = writeBuffer;
</span><span class='line'>      } else {    // Don't permanently allocate very large buffers.
</span><span class='line'>      cbuf = new char[len];
</span><span class='line'>      }
</span><span class='line'>      str.getChars(off, (off + len), cbuf, 0);
</span><span class='line'>      write(cbuf, 0, len);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>在每次写入操作的时候都有同步操作，再看一下lock对象</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * The object used to synchronize operations on this stream.  For
</span><span class='line'> * efficiency, a character-stream object may use an object other than
</span><span class='line'> * itself to protect critical sections.  A subclass should therefore use
</span><span class='line'> * the object in this field rather than &lt;tt&gt;this&lt;/tt&gt; or a synchronized
</span><span class='line'> * method.
</span><span class='line'> */
</span><span class='line'>protected Object lock;
</span><span class='line'>
</span><span class='line'>/**
</span><span class='line'> * Creates a new character-stream writer whose critical sections will
</span><span class='line'> * synchronize on the writer itself.
</span><span class='line'> */
</span><span class='line'>protected Writer() {
</span><span class='line'>  this.lock = this;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>原来lock就是Writer对象本身</p>

<p>总结：</p>

<p>Log4j如何保证写文件多线程安全?</p>

<p>AppenderSkeleton本身append操作是同步过的，保证了每次append是原子操作的</p>

<p>Bonus：java中的Writer的写操作也是原子的（经过同步）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Log4j源码学习之--Logger.getLogger]]></title>
    <link href="http://superbaboon.github.io/blog/2014/03/16/log4j-source-learning-logger-getlogger/"/>
    <updated>2014-03-16T17:22:38+08:00</updated>
    <id>http://superbaboon.github.io/blog/2014/03/16/log4j-source-learning-logger-getlogger</id>
    <content type="html"><![CDATA[<!--more-->


<ul>
<li>Logger.getLogger的执行逻辑</li>
</ul>


<p><img src="http://superbaboon.github.io/images/Log4j_logger_getLogger_timeline.jpg" alt="时序图" /></p>

<p>可以看出，实际的Logger创建有Hierachy完成，先贴源码</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public Logger getLogger(String name, LoggerFactory factory) {
</span><span class='line'>    
</span><span class='line'>    //System.out.println("getInstance("+name+") called.");
</span><span class='line'>    CategoryKey key = new CategoryKey(name);
</span><span class='line'>    
</span><span class='line'>    // Synchronize to prevent write conflicts. Read conflicts (in
</span><span class='line'>    // getChainedLevel method) are possible only if variable
</span><span class='line'>    // assignments are non-atomic.
</span><span class='line'>    Logger logger;
</span><span class='line'>
</span><span class='line'>    synchronized(ht) {
</span><span class='line'>      Object o = ht.get(key);
</span><span class='line'>      if(o == null) {
</span><span class='line'>          logger = factory.makeNewLoggerInstance(name);
</span><span class='line'>          logger.setHierarchy(this);
</span><span class='line'>          ht.put(key, logger);
</span><span class='line'>          updateParents(logger);
</span><span class='line'>          return logger;
</span><span class='line'>      } else if(o instanceof Logger) {
</span><span class='line'>          return (Logger) o;
</span><span class='line'>      } else if (o instanceof ProvisionNode) {
</span><span class='line'>          logger = factory.makeNewLoggerInstance(name);
</span><span class='line'>          logger.setHierarchy(this);
</span><span class='line'>          ht.put(key, logger);
</span><span class='line'>          updateChildren((ProvisionNode) o, logger);
</span><span class='line'>          updateParents(logger);
</span><span class='line'>          return logger;
</span><span class='line'>      }
</span><span class='line'>      else {
</span><span class='line'>          // It should be impossible to arrive here
</span><span class='line'>          return null;  // but let's keep the compiler happy.
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h4>源码分析</h4>

<ul>
<li>Hierachy内部使用Hashtable这个数据结构存储Logger</li>
<li>获取流程：

<ol>
<li> 如果不存在，则创建新的Logger，并updateParents(后面描述)</li>
<li> 如果存在，并且是Logger类型，则直接返回</li>
<li> 如果存在，并且<strong>ProvisionNode</strong>类型，创建Logger，并updateChildren和updateParents</li>
</ol>
</li>
</ul>


<h5>ProvisionNode</h5>

<p>源码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class ProvisionNode extends Vector {
</span><span class='line'>    
</span><span class='line'>  ProvisionNode(Logger logger) {
</span><span class='line'>    super();
</span><span class='line'>    this.addElement(logger);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>代码中可以看出ProvisionNode是Vector类型，用于维护它的子孙logger的指针。</p>

<h4>updateParents逻辑</h4>

<p>源码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private void updateParents(Logger cat) {
</span><span class='line'>  String name = cat.name;
</span><span class='line'>  int length = name.length();
</span><span class='line'>  boolean parentFound = false;
</span><span class='line'>
</span><span class='line'>  //System.out.println("UpdateParents called for " + name);
</span><span class='line'>
</span><span class='line'>  // if name = "w.x.y.z", loop thourgh "w.x.y", "w.x" and "w", but not "w.x.y.z"
</span><span class='line'>  for(int i = name.lastIndexOf('.', length-1); i &gt;= 0;
</span><span class='line'>                                 i = name.lastIndexOf('.', i-1))  {
</span><span class='line'>    String substr = name.substring(0, i);
</span><span class='line'>
</span><span class='line'>    //System.out.println("Updating parent : " + substr);
</span><span class='line'>    CategoryKey key = new CategoryKey(substr); // simple constructor
</span><span class='line'>    Object o = ht.get(key);
</span><span class='line'>    // Create a provision node for a future parent.
</span><span class='line'>    if(o == null) {
</span><span class='line'>      //System.out.println("No parent "+substr+" found. Creating ProvisionNode.");
</span><span class='line'>      ProvisionNode pn = new ProvisionNode(cat);
</span><span class='line'>      ht.put(key, pn);
</span><span class='line'>    } else if(o instanceof Category) {
</span><span class='line'>      parentFound = true;
</span><span class='line'>      cat.parent = (Category) o;
</span><span class='line'>      //System.out.println("Linking " + cat.name + " -&gt; " + ((Category) o).name);
</span><span class='line'>      break; // no need to update the ancestors of the closest ancestor
</span><span class='line'>    } else if(o instanceof ProvisionNode) {
</span><span class='line'>      ((ProvisionNode) o).addElement(cat);
</span><span class='line'>    } else {
</span><span class='line'>      Exception e = new IllegalStateException("unexpected object type " +
</span><span class='line'>              o.getClass() + " in ht.");
</span><span class='line'>      e.printStackTrace();
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>  // If we could not find any existing parents, then link with root.
</span><span class='line'>  if(!parentFound)
</span><span class='line'>    cat.parent = root;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Logger.getLogger(&ldquo;com.foo.bar.X&rdquo;)的流程即：</p>

<ul>
<li>依次对名字com.foo.bar,com.foo,com的logger进行下面逻辑处理

<ol>
<li> 如果logger不存在，则创建ProvisionNode对象，先占据位置</li>
<li> 如果logger存在，并且是logger类型，则直接将当前logger的parent指向该logger，并直接返回</li>
<li> 如果logger存在，并且是ProvisionNode，则将当前logger作为该ProvisionNode的子孙节点</li>
</ol>
</li>
<li>如果没有找到parent logger， 则将当前logger的parent指向rootLogger</li>
</ul>


<h4>updateChildren逻辑</h4>

<p>源码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private void updateChildren(ProvisionNode pn, Logger logger) {
</span><span class='line'>  //System.out.println("updateChildren called for " + logger.name);
</span><span class='line'>  final int last = pn.size();
</span><span class='line'>
</span><span class='line'>  for(int i = 0; i &lt; last; i++) {
</span><span class='line'>    Logger l = (Logger) pn.elementAt(i);
</span><span class='line'>    //System.out.println("Updating child " +p.name);
</span><span class='line'>
</span><span class='line'>    // Unless this child already points to a correct (lower) parent,
</span><span class='line'>    // make cat.parent point to l.parent and l.parent to cat.
</span><span class='line'>    if(!l.parent.name.startsWith(logger.name)) {
</span><span class='line'>      logger.parent = l.parent;
</span><span class='line'>      l.parent = logger;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>注意：Logger.getLogger(&ldquo;com.foo.bar.X&rdquo;),如果com.foo.bar.X对应的logger是ProvisionNode类型，则会通过updateChildren来更新子孙节点的parent logger指向</p>

<p>举个例子：</p>

<p>前置条件:</p>

<p>1.先调用Logger.getLogger(&ldquo;com.foo.bar.X&rdquo;);
2.然后调用Logger.getLogger(&ldquo;com.foo&rdquo;)；</p>

<p>执行第一步</p>

<ul>
<li>名字为com.foo.bar.X的logger会被创建</li>
<li>名字为com.foo.bar、com.foo和com的logger都会被创建成ProvisionNode对象；</li>
<li>com.foo.bar.X的parent会指向RootLogger</li>
</ul>


<p>执行第二步</p>

<ul>
<li>名字为com.foo的logger会被创建，假设名字为A</li>
<li>com.foo.bar.X的parent会指向A</li>
<li>A.parent会指向RootLogger</li>
</ul>


<p>结论</p>

<ol>
<li>logger的继承关系是通过不断调用Logger.getLogger来创建起来的，并且这样的继承关系靠Hierarchy类来维护</li>
<li>相同名字的logger只会闯将一次（不同的ClassLoader例外）</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Log4j源码学习]]></title>
    <link href="http://superbaboon.github.io/blog/2014/03/15/log4j-source-learning-start/"/>
    <updated>2014-03-15T11:50:29+08:00</updated>
    <id>http://superbaboon.github.io/blog/2014/03/15/log4j-source-learning-start</id>
    <content type="html"><![CDATA[<!--more-->


<ul>
<li>解决什么问题

<ul>
<li>[核心]：哪些地方需要打印日志？</li>
<li>[核心]：日志需要打印到什么地方？</li>
<li>[核心]：日志需要用什么格式打印？</li>
<li>[优化]：不侵入业务代码的前提下，如何实现某些情况打印？某些情况不打印？</li>
<li>[优化]：不侵入业务代码的前提下，如何满足一条日志可以输出到不同渠道（文件、控制台）</li>
<li>[优化]：不侵入业务代码的情况下，增加添加输出格式，增加输出渠道等问题</li>
</ul>
</li>
</ul>


<hr />

<ul>
<li>Log4j的解决方式

<ul>
<li>不侵入业务代码的情况下，实现某些情况下打印，某些情况不打印?

<ul>
<li>Level机制</li>
</ul>
</li>
<li>如何满足一条日志输出到不同渠道

<ul>
<li>日志和输出分离</li>
</ul>
</li>
<li>如何在不修改业务代码的情况下，增加添加输出格式，增加输出渠道等问题

<ul>
<li>配置化（properties文件、xml配置）</li>
</ul>
</li>
</ul>
</li>
</ul>


<hr />

<h3>Log4j的核心组件</h3>

<p><strong><a href="http://logging.apache.org/log4j/1.2/manual.html">官方链接</a></strong></p>

<ul>
<li>Logger：日志埋点（所有需要输出日志的地方）</li>
<li>Appender：日志的输出渠道</li>
<li>Layout：日志的格式</li>
</ul>


<p><img src="http://superbaboon.github.io/images/Log4j_logger_appender_layout_uml.jpg" alt="UML" /></p>

<h4>Logger</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 生成Logger对象
</span><span class='line'>private final Logger logger = LoggerFactory.getLogger(A.class);
</span><span class='line'>
</span><span class='line'>// 打印日志
</span><span class='line'>logger.info("info…");
</span><span class='line'>logger.warn("warn…");
</span><span class='line'>logger.error("error…");</span></code></pre></td></tr></table></div></figure>


<h4>Appender(一般情况下不需要在程序代码中使用)</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;appender name="CONSOLE" class="xxx.xxx.ExtendedConsoleAppender"&gt;
</span><span class='line'>  &lt;param name="Target" value="System.out" /&gt;
</span><span class='line'>  &lt;layout class="org.apache.log4j.PatternLayout"&gt;
</span><span class='line'>      &lt;param name="ConversionPattern" value="[review-web]%d %-5p [%c %L] %m%n" /&gt;
</span><span class='line'>  &lt;/layout&gt;
</span><span class='line'>&lt;/appender&gt;</span></code></pre></td></tr></table></div></figure>


<h3>Log4j的Level机制</h3>

<ul>
<li>解决的问题：不侵入业务代码的前提下，实现某些情况下打印，某些情况不打印?

<ul>
<li>Logger.setLevel(Level.INFO)</li>
<li>logger.warn(&ldquo;warn…&rdquo;)</li>
<li>compare</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>A log request of level p in a logger with (either assigned or inherited, whichever is appropriate) level q, is enabled if p &gt;= q.</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// get a logger instance named "com.foo"
</span><span class='line'>Logger  logger = Logger.getLogger("com.foo");
</span><span class='line'>
</span><span class='line'>// Now set its level. Normally you do not need to set the
</span><span class='line'>// level of a logger programmatically. This is usually done
</span><span class='line'>// in configuration files.
</span><span class='line'>logger.setLevel(Level.INFO);
</span><span class='line'>
</span><span class='line'>Logger barlogger = Logger.getLogger("com.foo.Bar");
</span><span class='line'>
</span><span class='line'>// This request is enabled, because WARN &gt;= INFO.
</span><span class='line'>logger.warn("Low fuel level.");
</span><span class='line'>
</span><span class='line'>// This request is disabled, because DEBUG &lt; INFO.
</span><span class='line'>logger.debug("Starting search for nearest gas station.");
</span><span class='line'>
</span><span class='line'>// The logger instance barlogger, named "com.foo.Bar",
</span><span class='line'>// will inherit its level from the logger named
</span><span class='line'>// "com.foo" Thus, the following request is enabled
</span><span class='line'>// because INFO &gt;= INFO.
</span><span class='line'>barlogger.info("Located nearest gas station.");
</span><span class='line'>
</span><span class='line'>// This request is disabled, because DEBUG &lt; INFO.
</span><span class='line'>barlogger.debug("Exiting gas station search");) </span></code></pre></td></tr></table></div></figure>


<h3>Appender机制</h3>

<ul>
<li>解决的问题：不侵入业务代码的前提下，如何满足一条日志可以输出到不同渠道（文件、控制台）

<ul>
<li>日志打印与输出分离</li>
<li>一个Logger有多个Appender</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 伪代码
</span><span class='line'>
</span><span class='line'>logger.addAppender(new ConsoleAppender());
</span><span class='line'>logger.addAppender(new FileAppender());
</span><span class='line'>
</span><span class='line'>logger.warn(msg)等价于
</span><span class='line'>
</span><span class='line'>for (Appender appender : appenderList) {
</span><span class='line'>  appender.doAppender(msg)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>配置化</h3>

<ul>
<li>解决的问题：不侵入业务代码的情况下，增加添加输出格式，增加输出渠道等问题

<ul>
<li>配置化</li>
<li>XML配置、Properties配置</li>
</ul>
</li>
</ul>


<h4>Properties配置</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>log4j.rootLogger=debug, R
</span><span class='line'>
</span><span class='line'>log4j.appender.R=org.apache.log4j.RollingFileAppender
</span><span class='line'>log4j.appender.R.File=example.log
</span><span class='line'>
</span><span class='line'>log4j.appender.R.layout=org.apache.log4j.PatternLayout
</span><span class='line'>log4j.appender.R.layout.ConversionPattern=%p %t %c - %m%n</span></code></pre></td></tr></table></div></figure>


<h4>等价的XML配置</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;appender name="R" class="org.apache.log4j.RollingFileAppender"&gt;
</span><span class='line'>   &lt;param name="File" value="example.log" /&gt;
</span><span class='line'>   &lt;layout class="org.apache.log4j.PatternLayout"&gt;
</span><span class='line'>      &lt;param name="ConversionPattern" value="[review-web]%d %-5p [%c %L] %m%n" /&gt;
</span><span class='line'>   &lt;/layout&gt;
</span><span class='line'>&lt;/appender&gt;
</span><span class='line'>
</span><span class='line'>&lt;root&gt;
</span><span class='line'>   &lt;level value="debug" /&gt;
</span><span class='line'>   &lt;appender-ref ref="R" /&gt;
</span><span class='line'>&lt;/root&gt;</span></code></pre></td></tr></table></div></figure>


<h3>Bonus</h3>

<h4>Logger的继承机制</h4>

<h5>Name Inheritance</h5>

<ul>
<li>com.foo.bar &mdash;&mdash;> com.foo</li>
<li>Logger logger = Logger.getLogger(&ldquo;com.foo.bar&rdquo;);</li>
<li><strong>RootLogger除外：不可以通过getLogger获取</strong></li>
</ul>


<h5>Level Inheritance</h5>

<table>
<thead>
<tr>
<th></th>
<th> Logger name </th>
<th> Level </th>
<th> Inherited Level </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Root </td>
<td> LevelRoot  </td>
<td> LevelRoot </td>
</tr>
<tr>
<td></td>
<td> X </td>
<td> LevelX  </td>
<td> LevelX </td>
</tr>
<tr>
<td></td>
<td> X.Y </td>
<td> none  </td>
<td> LevelX </td>
</tr>
<tr>
<td></td>
<td> X.Y.Z </td>
<td> LevelXYZ  </td>
<td> LevelXYZ </td>
</tr>
</tbody>
</table>


<h4>Appender Additivity</h4>

<ul>
<li>默认情况下：一个Logger&copy;的日志请求&mdash;>C.parent&mdash;>…&mdash;>RootLogger</li>
<li>不需要扩散：就配置Logger的Additivity为false</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;logger name="com.ibatis" additivity="false"&gt;
</span><span class='line'>   &lt;level value="WARN" /&gt;
</span><span class='line'>   &lt;appender-ref ref="CONSOLE" /&gt;
</span><span class='line'>   &lt;appender-ref ref="ibatisAppender" /&gt;
</span><span class='line'>&lt;/logger&gt;</span></code></pre></td></tr></table></div></figure>


<p>Rules of Appender Additivity</p>

<table>
<thead>
<tr>
<th></th>
<th> Logger name </th>
<th> Added Appenders  </th>
<th> Additivity Flag </th>
<th> Output Targets </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td> Root </td>
<td> A1  </td>
<td> <strong>not applicable</strong> </td>
<td> A1 </td>
</tr>
<tr>
<td></td>
<td> X </td>
<td> A2  </td>
<td> true </td>
<td> A1, A2 </td>
</tr>
<tr>
<td></td>
<td> X.Y </td>
<td> A3 </td>
<td> false </td>
<td> A3 </td>
</tr>
<tr>
<td></td>
<td> X.Y.Z </td>
<td> A4 </td>
<td> true </td>
<td> A3, A4 </td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring--ApplicationEvent]]></title>
    <link href="http://superbaboon.github.io/blog/2014/03/07/demo/"/>
    <updated>2014-03-07T22:10:33+08:00</updated>
    <id>http://superbaboon.github.io/blog/2014/03/07/demo</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
